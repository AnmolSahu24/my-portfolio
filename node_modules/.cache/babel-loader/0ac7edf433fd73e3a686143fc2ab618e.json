{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactLottiePlayer = _interopRequireDefault(require(\"react-lottie-player\"));\nvar _parseUnit3 = _interopRequireDefault(require(\"parse-unit\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar animationData = require(\"./animationData.json\");\nvar NightModeToggle = function NightModeToggle(_ref) {\n  var size = _ref.size,\n    checked = _ref.checked,\n    onChange = _ref.onChange,\n    speed = _ref.speed,\n    className = _ref.className;\n  var _parseUnit = (0, _parseUnit3[\"default\"])(size),\n    _parseUnit2 = _slicedToArray(_parseUnit, 2),\n    sizeValue = _parseUnit2[0],\n    sizeUnit = _parseUnit2[1];\n  var _useState = (0, _react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isReadyToAnimate = _useState2[0],\n    setReadyToAnimate = _useState2[1];\n  var segmentsToPlay = checked ? [2, 50] : [51, 96];\n  var segmentToGoTo = checked ? 51 : 2;\n  return _react[\"default\"].createElement(\"button\", {\n    onClick: function onClick() {\n      setReadyToAnimate(true);\n      onChange(!checked);\n    },\n    style: {\n      cursor: \"pointer\",\n      overflow: \"hidden\",\n      width: \"\".concat(sizeValue).concat(sizeUnit || \"px\"),\n      height: \"\".concat(sizeValue * .47).concat(sizeUnit || \"px\"),\n      appearance: \"none\",\n      MozAppearance: \"none\",\n      WebkitAppearance: \"none\",\n      border: \"none\",\n      backgroundColor: \"transparent\",\n      padding: 0\n    },\n    \"aria-hidden\": \"true\",\n    className: className\n  }, _react[\"default\"].createElement(\"div\", {\n    style: {\n      display: \"flex\",\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      marginTop: \"\".concat(sizeValue * -.575).concat(sizeUnit || \"px\"),\n      marginLeft: \"\".concat(sizeValue * -.32).concat(sizeUnit || \"px\"),\n      width: \"\".concat(sizeValue * 1.65).concat(sizeUnit || \"px\"),\n      height: \"\".concat(sizeValue * 1.65).concat(sizeUnit || \"px\")\n    }\n  }, _react[\"default\"].createElement(_reactLottiePlayer[\"default\"], {\n    key: \"$preventGlitches\",\n    play: isReadyToAnimate,\n    speed: speed,\n    animationData: animationData,\n    loop: false,\n    segments: segmentsToPlay,\n    goTo: segmentToGoTo\n  })));\n};\nNightModeToggle.propTypes = {\n  size: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].number, _propTypes[\"default\"].string]),\n  checked: _propTypes[\"default\"].bool,\n  onChange: _propTypes[\"default\"].func,\n  speed: _propTypes[\"default\"].number,\n  className: _propTypes[\"default\"].string\n};\nNightModeToggle.defaultProps = {\n  size: 85,\n  checked: false,\n  onChange: function onChange(nextValue) {\n    return null;\n  },\n  speed: 1.3,\n  className: null\n};\nvar propsAreEqual = function propsAreEqual(prevProps, nextProps) {\n  return prevProps.size === nextProps.size && prevProps.checked === nextProps.checked && prevProps.speed === nextProps.speed && prevProps.className === nextProps.className;\n};\nvar _default = (0, _react.memo)(NightModeToggle, propsAreEqual);\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}